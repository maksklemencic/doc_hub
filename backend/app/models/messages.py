from typing import List, Optional
from datetime import datetime
import uuid
from pydantic import BaseModel, Field
from backend.db_init.db_init import Message, Space

# class MessageResponse(BaseModel):
#     id: uuid.UUID = Field(..., description="Unique identifier (UUID) of the message.")
#     space_id: uuid.UUID = Field(..., description="Identifier of the space the message belongs to.")
#     user_id: uuid.UUID = Field(..., description="Identifier of the user who created the message.")
#     content: str = Field(..., description="Content of the message.")
#     created_at: Optional[datetime] = Field(None, description="Timestamp when the message was created.")

#     class Config:
#         from_attributes = True

class LLMResponse(BaseModel):
    query: str = Field(..., description="The original query sent to the LLM.")
    response: str = Field(..., description="The response generated by the LLM.")
    context: str = Field(..., description="Context used for generating the response.")

class PaginationMetadata(BaseModel):
    limit: int = Field(..., ge=1, le=100, description="Number of spaces returned in the current page, between 1 and 100.")
    offset: int = Field(..., ge=0, description="Number of spaces skipped before the current page, non-negative.")
    total_count: int = Field(..., ge=0, description="Total number of spaces available for the user.")

class MessageResponse(BaseModel):
    created_at: Optional[datetime] = Field(None, description="Timestamp when the message was created.")
    id: uuid.UUID = Field(..., description="Unique identifier (UUID) of the message.")
    space_id: uuid.UUID = Field(..., description="Identifier of the space the message belongs to.")
    user_id: uuid.UUID = Field(..., description="Identifier of the user who created the message.")

class MessageResponseWrapper(BaseModel):
    data: LLMResponse = Field(..., description="The response data containing the query, response, and context.")
    message: MessageResponse = Field(..., description="The message object containing metadata about the created message.")

class CreateMessageRequest(BaseModel):
    content: str = Field(..., description="The content of the message to create.")
    stream: bool = Field(False, description="Whether to stream the response or not.")
    top_k: int = Field(5, ge=1, le=100, description="Number of top results to return when using context.")
    use_context: bool = Field(True, description="Whether to use context from the RAG system.")


class GetMessagesRequest(BaseModel):
    limit: int = Field(10, ge=1, le=100, description="Number of messages to return per page.")
    offset: int = Field(0, ge=0, description="Number of messages to skip before starting the page.")

class GetMessagesResponseWrapper(BaseModel):
    messages: List[MessageResponse]
    pagination: PaginationMetadata = Field(..., description="Pagination metadata including limit, offset, and total count.")

